"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[309],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var m=r.createContext({}),u=function(e){var t=r.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(m.Provider,{value:t},e.children)},s="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,m=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),s=u(n),c=a,k=s["".concat(m,".").concat(c)]||s[c]||d[c]||i;return n?r.createElement(k,l(l({ref:t},p),{},{components:n})):r.createElement(k,l({ref:t},p))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o[s]="string"==typeof e?e:a,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},343:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const i={},l="Matrix4",o={unversionedId:"modules/core/api-reference/matrix4",id:"modules/core/api-reference/matrix4",title:"Matrix4",description:"A 4x4 matrix. Any arguments to Matrix4 methods can be plain JavaScript arrays or other math.gl objects.",source:"@site/../docs/modules/core/api-reference/matrix4.md",sourceDirName:"modules/core/api-reference",slug:"/modules/core/api-reference/matrix4",permalink:"/docs/modules/core/api-reference/matrix4",draft:!1,editUrl:"https://github.com/uber-web/math.gl/tree/master/website/../docs/modules/core/api-reference/matrix4.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Matrix3",permalink:"/docs/modules/core/api-reference/matrix3"},next:{title:"Pose",permalink:"/docs/modules/core/api-reference/pose"}},m={},u=[{value:"Usage",id:"usage",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Methods",id:"methods",level:2},{value:"constructor()",id:"constructor",level:5},{value:"identity(): this",id:"identity-this",level:5},{value:"set(...number): this",id:"setnumber-this",level:5},{value:"fromQuaternion(quaternion: Quaternion): this",id:"fromquaternionquaternion-quaternion-this",level:5},{value:"frustum(options: {left: number, right: number, bottom: number, top: number, near: number, far: number}): this",id:"frustumoptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this",level:5},{value:"lookAt(options?: {eye: number, center: number, up: number}): this",id:"lookatoptions-eye-number-center-number-up-number-this",level:5},{value:"ortho(options: {left: number, right: number, bottom: number, top: number, near?: number, far: number}): this",id:"orthooptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this",level:5},{value:"orthographic",id:"orthographic",level:5},{value:"perspective",id:"perspective",level:5},{value:"determinant(): number",id:"determinant-number",level:5},{value:"transpose(): this",id:"transpose-this",level:5},{value:"invert(): this",id:"invert-this",level:5},{value:"multiplyLeft(matrix: number16): this",id:"multiplyleftmatrix-number16-this",level:5},{value:"multiplyRight(matrix: number16): this",id:"multiplyrightmatrix-number16-this",level:5},{value:"rotateX(radians: number): this",id:"rotatexradians-number-this",level:5},{value:"rotateY(radians: number): this",id:"rotateyradians-number-this",level:5},{value:"rotateZ(radians: number): this",id:"rotatezradians-number-this",level:5},{value:"rotateXYZ(angles: rx: number, ry: number, rz: number): this",id:"rotatexyzangles-rx-number-ry-number-rz-number-this",level:5},{value:"rotateAxis(radians: number, axis: number3): this",id:"rotateaxisradians-number-axis-number3-this",level:5},{value:"scale(factor: number | number3): this",id:"scalefactor-number--number3-this",level:5},{value:"translate(scale: number3): this",id:"translatescale-number3-this",level:5},{value:"Decomposition",id:"decomposition",level:4},{value:"getRotation(result?: number16) : number16",id:"getrotationresult-number16--number16",level:5},{value:"getRotationMatrix3(result?: number9) : number9",id:"getrotationmatrix3result-number9--number9",level:5},{value:"getTranslation(result?: number3) : number3",id:"gettranslationresult-number3--number3",level:5},{value:"getScale(result?: number3) : number3",id:"getscaleresult-number3--number3",level:5},{value:"Point Transformations",id:"point-transformations",level:4},{value:"transformAsPoint(vector : number4) : number4",id:"transformaspointvector--number4--number4",level:5},{value:"transformAsVector(vector : number4) : number4",id:"transformasvectorvector--number4--number4",level:5},{value:"Remarks",id:"remarks",level:2}],p={toc:u},s="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(s,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"matrix4"},"Matrix4"),(0,a.kt)("p",null,"A 4x4 matrix. Any arguments to ",(0,a.kt)("inlineCode",{parentName:"p"},"Matrix4")," methods can be plain JavaScript arrays or other ",(0,a.kt)("inlineCode",{parentName:"p"},"math.gl")," objects."),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {Matrix4} from `math.gl`;\n")),(0,a.kt)("p",null,"Copy a matrix to a ",(0,a.kt)("inlineCode",{parentName:"p"},"Matrix4")," so that it can be manipulated (and mutated) with ",(0,a.kt)("inlineCode",{parentName:"p"},"Matrix4")," methods:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const IDENTITY = [1, 0, ..., 1];\nconst m = new Matrix4(IDENTITY).translate([1, 0, 0]);\n")),(0,a.kt)("p",null,"Create a perspective projection matrix"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const projectionMatrix = new Matrix4().perspective({fov, aspect, near, far});\n")),(0,a.kt)("p",null,"Create an orthograhic projection matrix"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"")),(0,a.kt)("p",null,"Invert a matrix"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const inverse = matrix.invert();\n")),(0,a.kt)("p",null,"Transform a vector as a point (including translations)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const transform = new Matrix4();\nconst vector2 = transform.transformPoint([0, 0]);\nconst vector3 = transform.transformPoint([0, 1, 2]);\nconst vector4 = transform.transformPoint([0, 1, 2, 1]);\n")),(0,a.kt)("p",null,"Transform a vector as a direction (NOT including translations)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const transform = new Matrix4();\nconst vector2 = transform.transformDirection([0, 0]);\nconst vector3 = transform.transformDirection([0, 1, 2]);\nconst vector4 = transform.transformDirection([0, 1, 2, 1]);\n")),(0,a.kt)("h2",{id:"inheritance"},"Inheritance"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"class Matrix4 extends")," ",(0,a.kt)("a",{parentName:"p",href:"/docs/modules/core/api-reference/matrix"},(0,a.kt)("inlineCode",{parentName:"a"},"Matrix"))," ",(0,a.kt)("inlineCode",{parentName:"p"},"extends")," ",(0,a.kt)("a",{parentName:"p",href:"/docs/modules/core/api-reference/math-array"},(0,a.kt)("inlineCode",{parentName:"a"},"MathArray"))," ",(0,a.kt)("inlineCode",{parentName:"p"},"extends")," ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"},(0,a.kt)("inlineCode",{parentName:"a"},"Array")),"`"),(0,a.kt)("p",null,"Many basic methods are inherited:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.clone()")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.copy(array)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.set(...args)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.fromArray(array, offset = 0)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.toString()")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.toArray(array = [], offset = 0)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.equals(array)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.exactEquals(array)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.validate(array = this)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.check(array = this)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix4.normalize()"))),(0,a.kt)("p",null,"Since ",(0,a.kt)("inlineCode",{parentName:"p"},"Matrix4")," is a subclass of the built in JavaScript ",(0,a.kt)("inlineCode",{parentName:"p"},"Array")," it can be used directly as a parameter to any function expecting an ",(0,a.kt)("inlineCode",{parentName:"p"},"Array"),"."),(0,a.kt)("h2",{id:"methods"},"Methods"),(0,a.kt)("h5",{id:"constructor"},"constructor()"),(0,a.kt)("p",null,"Creates an empty ",(0,a.kt)("inlineCode",{parentName:"p"},"Matrix4")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"new Matrix4()")),(0,a.kt)("h5",{id:"identity-this"},"identity(): this"),(0,a.kt)("p",null,"Sets the matrix to the multiplicative identity matrix."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.identity()")),(0,a.kt)("h5",{id:"setnumber-this"},"set(...number): this"),(0,a.kt)("p",null,"Sets the elements of the matrix."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33)")),(0,a.kt)("h5",{id:"fromquaternionquaternion-quaternion-this"},"fromQuaternion(quaternion: Quaternion): this"),(0,a.kt)("p",null,"Sets the matrix to a transformation corresponding to the rotations represented by the given quaternion."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.fromQuaternion(quaternion)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"quaternion")," (",(0,a.kt)("inlineCode",{parentName:"li"},"Quaternion"),") - the quaternion to create matrix from")),(0,a.kt)("h5",{id:"frustumoptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this"},"frustum(options: {left: number, right: number, bottom: number, top: number, near: number, far: number}): this"),(0,a.kt)("p",null,"Generates a frustum matrix with the given bounds. The frustum far plane can be infinite."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.frustum({left, right, bottom, top, near, far})")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"left")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Left bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"right")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Right bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"bottom")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Bottom bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"top")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Top bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"near")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Near bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"far")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),"|",(0,a.kt)("inlineCode",{parentName:"li"},"Infinity"),") - Far bound of the frustum")),(0,a.kt)("h5",{id:"lookatoptions-eye-number-center-number-up-number-this"},"lookAt(options?: {eye: number, center: number, up: number}): this"),(0,a.kt)("p",null,"Generates a look-at matrix with the given eye position, focal point, and up axis"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.lookAt({eye, center, up})")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"eye")," (",(0,a.kt)("inlineCode",{parentName:"li"},"Vector3"),"|",(0,a.kt)("inlineCode",{parentName:"li"},"number[3]"),") - Position of the viewer"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"center"),"=",(0,a.kt)("inlineCode",{parentName:"li"},"[0, 0, 0]")," (",(0,a.kt)("inlineCode",{parentName:"li"},"Vector3"),"|",(0,a.kt)("inlineCode",{parentName:"li"},"number[3]"),") vec3 Point the viewer is looking at"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"up"),"=",(0,a.kt)("inlineCode",{parentName:"li"},"[0, 1, 0]")," (",(0,a.kt)("inlineCode",{parentName:"li"},"Vector3"),"|",(0,a.kt)("inlineCode",{parentName:"li"},"number[3]"),") vec3 vec3 pointing up")),(0,a.kt)("h5",{id:"orthooptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this"},"ortho(options: {left: number, right: number, bottom: number, top: number, near?: number, far: number}): this"),(0,a.kt)("p",null,"Generates a orthogonal projection matrix with the given bounds"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.ortho({left, right, bottom, top, near = 0.1, far = 500})")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"left")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Left bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"right")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Right bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"bottom")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Bottom bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"top")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Top bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"near")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Near bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"far")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Far bound of the frustum")),(0,a.kt)("h5",{id:"orthographic"},"orthographic"),(0,a.kt)("p",null,"Generates an orthogonal projection matrix with the same parameters\nas a perspective matrix (plus ",(0,a.kt)("inlineCode",{parentName:"p"},"focalDistance"),")."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Matrix4.orthographic({fovy, aspect, focalDistance, near, far})")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"fovy")," (",(0,a.kt)("inlineCode",{parentName:"p"},"number"),") - Vertical field of view in radians")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"aspect")," (",(0,a.kt)("inlineCode",{parentName:"p"},"number"),") - Aspect ratio. typically viewport width/height")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"focalDistance")," (",(0,a.kt)("inlineCode",{parentName:"p"},"number"),") - selects which plane in the perspective view frustum should be used to calculate the size of the orthographic view box.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"near"),"=",(0,a.kt)("inlineCode",{parentName:"p"},"0.1")," (",(0,a.kt)("inlineCode",{parentName:"p"},"number"),") - Near bound of the frustum")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"far"),"=",(0,a.kt)("inlineCode",{parentName:"p"},"500")," (",(0,a.kt)("inlineCode",{parentName:"p"},"number"),") - Far bound of the frustum"))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"In applications it is not unusual to want to offer both perspective and orthographic views and this method is supplied to make this as simple as possible.")),(0,a.kt)("h5",{id:"perspective"},"perspective"),(0,a.kt)("p",null,"Generates a perspective projection matrix with the given bounds. The frustum far plane can be infinite."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.perspective({ fovy = 45 * Math.PI - / 180, aspect = 1, near = 0.1, far = 500 })")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fovy"),"=",(0,a.kt)("inlineCode",{parentName:"li"},"45")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Vertical field of view in radians (default is 45 degrees specified in radians)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"aspect"),"=",(0,a.kt)("inlineCode",{parentName:"li"},"1")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Aspect ratio. typically viewport width/height"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"near"),"=",(0,a.kt)("inlineCode",{parentName:"li"},"0.1")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),") - Near bound of the frustum"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"far"),"=",(0,a.kt)("inlineCode",{parentName:"li"},"500")," (",(0,a.kt)("inlineCode",{parentName:"li"},"number"),"|",(0,a.kt)("inlineCode",{parentName:"li"},"Infinity"),") - Far bound of the frustum")),(0,a.kt)("h5",{id:"determinant-number"},"determinant(): number"),(0,a.kt)("p",null,"Returns the determinant of the matrix (does not modify the matrix)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"const determinant = matrix4.determinant()")),(0,a.kt)("p",null,"Returns (",(0,a.kt)("inlineCode",{parentName:"p"},"number"),") - the determinant"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the determinant is zero, the matrix is not invertible."),(0,a.kt)("li",{parentName:"ul"},"Determinant calculation is somewhat expensive.")),(0,a.kt)("h5",{id:"transpose-this"},"transpose(): this"),(0,a.kt)("p",null,"Sets this matrix to its transpose matrix."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.transpose()")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The transpose matrix mirrors the original matrix elements in the diagonal.")),(0,a.kt)("h5",{id:"invert-this"},"invert(): this"),(0,a.kt)("p",null,"Sets this matrix to its inverse matrix."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.invert()")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The inverse matrix mirrors the original matrix elements in the diagonal.")),(0,a.kt)("h5",{id:"multiplyleftmatrix-number16-this"},"multiplyLeft(matrix: number","[16]","): this"),(0,a.kt)("p",null,"Multiplies in another matrix from the left"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.multiplyLeft(matrix4)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When using ",(0,a.kt)("inlineCode",{parentName:"li"},"Matrix4")," to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).")),(0,a.kt)("h5",{id:"multiplyrightmatrix-number16-this"},"multiplyRight(matrix: number","[16]","): this"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.multiplyRight(matrix4)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When using ",(0,a.kt)("inlineCode",{parentName:"li"},"Matrix4")," to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).")),(0,a.kt)("h5",{id:"rotatexradians-number-this"},"rotateX(radians: number): this"),(0,a.kt)("p",null,"Adds a rotation by the given angle around the X axis. Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.rotateX(radians)")),(0,a.kt)("h5",{id:"rotateyradians-number-this"},"rotateY(radians: number): this"),(0,a.kt)("p",null,"Adds a rotation by the given angle around the Y axis."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"rotateY(radians)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Equivalent to right multiplying the new transform into the matrix but more performant.")),(0,a.kt)("h5",{id:"rotatezradians-number-this"},"rotateZ(radians: number): this"),(0,a.kt)("p",null,"Adds a rotation by the given angle around the Z axis."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.rotateZ(radians)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Equivalent to right multiplying the new transform into the matrix but more performant.")),(0,a.kt)("h5",{id:"rotatexyzangles-rx-number-ry-number-rz-number-this"},"rotateXYZ(angles: ","[rx: number, ry: number, rz: number]","): this"),(0,a.kt)("p",null,"Adds successive rotations by the given angles around the X, Y and Z axis."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"rotateXYZ([rx, ry, rz])")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Equivalent to right multiplying the new transform into the matrix but more performant.")),(0,a.kt)("h5",{id:"rotateaxisradians-number-axis-number3-this"},"rotateAxis(radians: number, axis: number","[3]","): this"),(0,a.kt)("p",null,"Adds successive rotations by the given angles around the X, Y and Z axis."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"rotateAxis(radians, axis)")),(0,a.kt)("p",null,"Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.kt)("h5",{id:"scalefactor-number--number3-this"},"scale(factor: number | number","[3]","): this"),(0,a.kt)("p",null,"Adds a scaling transform, each axis can be scaled independently."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.scale(factor)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"factor")," (number) - scale factor to be applied to each axis.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.scale([x, y, z])")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"x")," (number) - scale factor to be multiplied into x component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"y")," (number) - scale factor to be multiplied into y component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"z")," (number) - scale factor to be multiplied into z component")),(0,a.kt)("p",null,"Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"During vector transformation all coordinates will be multiplied with the given factors."),(0,a.kt)("li",{parentName:"ul"},"Scale with ",(0,a.kt)("inlineCode",{parentName:"li"},"-1")," will flip the coordinate system in that axis."),(0,a.kt)("li",{parentName:"ul"},"Scale with ",(0,a.kt)("inlineCode",{parentName:"li"},"0")," will drop that component.")),(0,a.kt)("h5",{id:"translatescale-number3-this"},"translate(scale: number","[3]","): this"),(0,a.kt)("p",null,"Adds a translation to the matrix."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"matrix4.translate([x, y, z])")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"x")," (number) - translation to be added to the x component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"y")," (number) - translation to be added to the y component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"z")," (number) - translation to be added to the z component")),(0,a.kt)("p",null,"Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.kt)("p",null,"During vector transformation the given translation values are added to each component of the vector being transformed."),(0,a.kt)("h4",{id:"decomposition"},"Decomposition"),(0,a.kt)("h5",{id:"getrotationresult-number16--number16"},"getRotation(result?: number","[16]",") : number","[16]"),(0,a.kt)("p",null,"Returns a 4x4 rotation matrix."),(0,a.kt)("h5",{id:"getrotationmatrix3result-number9--number9"},"getRotationMatrix3(result?: number","[9]",") : number","[9]"),(0,a.kt)("p",null,"Returns a 3x3 rotation matrix."),(0,a.kt)("h5",{id:"gettranslationresult-number3--number3"},"getTranslation(result?: number","[3]",") : number","[3]"),(0,a.kt)("p",null,"Returns the 3-element translation vector component of the affine transform described by the matrix."),(0,a.kt)("p",null,"For performance, an existing vector can be provided, if not a new vector will be returned."),(0,a.kt)("h5",{id:"getscaleresult-number3--number3"},"getScale(result?: number","[3]",") : number","[3]"),(0,a.kt)("p",null,"Returns the 3-element scale vector component of the affine transform described by the matrix."),(0,a.kt)("p",null,"For performance, an existing vector can be provided, if not a new vector will be returned."),(0,a.kt)("h4",{id:"point-transformations"},"Point Transformations"),(0,a.kt)("h5",{id:"transformaspointvector--number4--number4"},"transformAsPoint(vector : number","[4]",") : number","[4]"),(0,a.kt)("p",null,'Transforms any 2, 3 or 4 element vector as a "point" by multiplying it (from the right) with this matrix. ',(0,a.kt)("inlineCode",{parentName:"p"},"Point")," here means that the returned vector will include any translations in this matrix."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"const vector = matrix4.transformPoint(vector, out=)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"vector")," (",(0,a.kt)("inlineCode",{parentName:"p"},"Array"),"|",(0,a.kt)("inlineCode",{parentName:"p"},"Vector2"),"|",(0,a.kt)("inlineCode",{parentName:"p"},"Vector3"),"|",(0,a.kt)("inlineCode",{parentName:"p"},"Vector4"),")")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"out")," - unless supplied, will be a Vector2, Vector3 or Vector4, matching the length of input vector.\nReturns ",(0,a.kt)("inlineCode",{parentName:"p"},"out"),", or a newly minted ",(0,a.kt)("inlineCode",{parentName:"p"},"Vector2"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Vector3")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Vector4"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If ",(0,a.kt)("inlineCode",{parentName:"p"},"vector")," is specified in homogeneous coordinates, ",(0,a.kt)("inlineCode",{parentName:"p"},"w")," coordinate must NOT be ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If ",(0,a.kt)("inlineCode",{parentName:"p"},"vector")," is specified in homogeneous coordinates the returned vector will be ",(0,a.kt)("inlineCode",{parentName:"p"},"w")," adjusted, (i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"w")," coordinate will be ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", even if the supplied vector was not normalized)."))),(0,a.kt)("h5",{id:"transformasvectorvector--number4--number4"},"transformAsVector(vector : number","[4]",") : number","[4]"),(0,a.kt)("p",null,"Transforms any 2, 3 or 4 element vector interpreted as a direction (i.e. all vectors are based in the origin so the transformation not pick up any translations from the matrix)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"const vector = matrix4.transformDirection(vector, out)")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"vector")," is specified in homogeneous coordinates, ",(0,a.kt)("inlineCode",{parentName:"li"},"w")," coordinate must be ",(0,a.kt)("inlineCode",{parentName:"li"},"0"),".")),(0,a.kt)("h2",{id:"remarks"},"Remarks"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'All transforms are effectively "right multiplied" onto the matrix (meaning that during transform they will be applied in opposite order).'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Matrix4")," is stored internally in column major format (per WebGL conventions). This only matters when you read out the matrix to use it with other software.")))}d.isMDXComponent=!0}}]);