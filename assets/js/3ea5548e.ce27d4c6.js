"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[4764],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(n),c=o,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7003:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(7462),o=(n(7294),n(3905));const r={},i="3D Rotations",l={unversionedId:"modules/core/concepts/rotations",id:"modules/core/concepts/rotations",title:"3D Rotations",description:"This article is a work in progress.",source:"@site/../docs/modules/core/concepts/rotations.md",sourceDirName:"modules/core/concepts",slug:"/modules/core/concepts/rotations",permalink:"/docs/modules/core/concepts/rotations",draft:!1,editUrl:"https://github.com/uber-web/math.gl/tree/master/website/../docs/modules/core/concepts/rotations.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"3D Coordinate Systems",permalink:"/docs/modules/core/concepts/coordinate-systems"}},s={},u=[{value:"Properties of 3D Rotations",id:"properties-of-3d-rotations",level:3},{value:"Parametrizing 3D Rotations",id:"parametrizing-3d-rotations",level:2},{value:"Rotation Axis and Angle",id:"rotation-axis-and-angle",level:3},{value:"Euler Angles",id:"euler-angles",level:3},{value:"Unit Quaternions",id:"unit-quaternions",level:3},{value:"Rotation Matrices",id:"rotation-matrices",level:2},{value:"Properties of Rotation Matrices",id:"properties-of-rotation-matrices",level:2},{value:"Converting between Rotation Representations",id:"converting-between-rotation-representations",level:2},{value:"Executing Rotation Transformations",id:"executing-rotation-transformations",level:2},{value:"Rotations using Rotation Matrices",id:"rotations-using-rotation-matrices",level:2},{value:"Combining Rotations",id:"combining-rotations",level:2},{value:"Interpolating Rotations",id:"interpolating-rotations",level:2},{value:"Background: Rotations are Complicated",id:"background-rotations-are-complicated",level:2},{value:"Background: More on Euler Angles",id:"background-more-on-euler-angles",level:2},{value:"Remarks",id:"remarks",level:2}],p={toc:u},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"3d-rotations"},"3D Rotations"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"This article is a work in progress.")),(0,o.kt)("p",null,'math.gl provides a "standard 3D library complement" of mathematical classes for handling rotations in 2D and 3D, such as classes for manipulating ',(0,o.kt)("inlineCode",{parentName:"p"},"Euler")," angles and ",(0,o.kt)("inlineCode",{parentName:"p"},"Quaternion"),"s. As in any 3D math library, the key goals are enabling applications to easily and intuitively specify (parametrize) rotations, combine them with other rotations and other transformations, and ultimately transform points with the rotations or resulting transformations."),(0,o.kt)("p",null,"While math.gl is intended to help programmers' implement the typical 3D application's rotation functionality with a minimum amount of knowledge, and does not even attempt to support rotations in more than 3 dimensions, it should be pointed out that the mathematical treatment of rotations can be very complicated. For some context on this see the background section at the end of this article."),(0,o.kt)("h3",{id:"properties-of-3d-rotations"},"Properties of 3D Rotations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"In contrast to 2D rotations, 3D rotations are not order-independent, meaning that applying the same two rotations in different order will often yield different results."),(0,o.kt)("li",{parentName:"ul"},"However, by ",(0,o.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem"},"Euler's Rotation Theorem"),", two 3D rotations around the origin can always be expressed as (combined into) another single 3D rotation around the origin."),(0,o.kt)("li",{parentName:"ul"},"A 3D rotation requires a minimum of three values to be fully specified (and even then can require careful definitions of which conventions are used).")),(0,o.kt)("p",null,"Also, a simple observation: Rotations around arbitrary points can be treated as rotations around the origin simply by applying a translation before the rotation, and the inverse translation after the rotation. Therefore, for simplicity, this discussion focuses solely on rotations around the origin."),(0,o.kt)("h2",{id:"parametrizing-3d-rotations"},"Parametrizing 3D Rotations"),(0,o.kt)("p",null,"A minimum of three values are required to fully specify a 3D rotation (another result of Euler's), e.g, Euler angles or unit quaternions."),(0,o.kt)("p",null,"However in many cases the best way to specify a rotation is to use four parameters: an axis and an angle."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Representation"),(0,o.kt)("th",{parentName:"tr",align:null},"Interpolation"),(0,o.kt)("th",{parentName:"tr",align:null},"Addition"),(0,o.kt)("th",{parentName:"tr",align:null},"Transforming points"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Vector/Angle"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"Good")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Quaternion"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent"),(0,o.kt)("td",{parentName:"tr",align:null},"Good")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4x4 Matrix"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Euler angle"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"-")))),(0,o.kt)("h3",{id:"rotation-axis-and-angle"},"Rotation Axis and Angle"),(0,o.kt)("p",null,"Per the Euler Rotation Theorem, any two 3D rotations can be combined into a single 3D rotation. A single 3D rotation happens around an axis, and the rotation is a certain angle. This means that it is possible to specify a rotation using four very understanable values: an axis and an angle."),(0,o.kt)("h3",{id:"euler-angles"},"Euler Angles"),(0,o.kt)("p",null,'One of the more "human readable" representation of a 3D rotation is the "Euler angle", simplistically, an "Euler angle" completely specifies a rotation using only 3 values, which are all "human readable" angles around the three coordinate axes, which is very appealing.'),(0,o.kt)("p",null,"However, the conventions for ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Euler_angles"},"Euler angle values")," can vary in a number of ways. Following three.js, the math.gl ",(0,o.kt)("inlineCode",{parentName:"p"},"Euler")," class uses intrinsic Tait-Bryan angles."),(0,o.kt)("p",null,'Note that the large number of representations means that Euler angles exchanged between e.g. different software systems may not be directly compatible (and in addition, converting between the various representations is not exactly easy), so unless care is taken this can cause "mind-numbing" confusion.'),(0,o.kt)("p",null,"Because of the variability, a good approach is often to be extremely careful when importing and exporting Euler angles from your code, and convert angle Euler angles to Matrix or Quaternion representations (which are much less ambiguous) for further manipulation."),(0,o.kt)("h3",{id:"unit-quaternions"},"Unit Quaternions"),(0,o.kt)("p",null,'"Unit quaternions" are normally the best representation for "manipulation" of 3D rotations. Manpulation here mainly refers to the "composition" or "addition" and interpolation of rotations.'),(0,o.kt)("p",null,"Note that unit quaternions are simply quaternions of norm (or length) equal to ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),", and while a general quaternion (as the name suggests) contains four components, a unit quaternion needs only three values to be fully specified."),(0,o.kt)("p",null,"Unit quaternions can be used to model 3 dimensional rotations."),(0,o.kt)("p",null,"qr",(0,o.kt)("em",{parentName:"p"},"v"),"qr-1"),(0,o.kt)("p",null,"Interpolation of quaternions is done using Spherical Linear intERPolation (aka SLERP)."),(0,o.kt)("h2",{id:"rotation-matrices"},"Rotation Matrices"),(0,o.kt)("p",null,"When combining rotations with other transformations (translations, scalings, projections etc), 4x4 matrices are the representation of choice."),(0,o.kt)("h2",{id:"properties-of-rotation-matrices"},"Properties of Rotation Matrices"),(0,o.kt)("p",null,"A rotation matrix"),(0,o.kt)("p",null,"T\nRR = I"),(0,o.kt)("p",null,"Note that a matrix R satisfying this can also include an inversion (improper rotation matrix)"),(0,o.kt)("h2",{id:"converting-between-rotation-representations"},"Converting between Rotation Representations"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"new Euler();\nnew Euler();\n")),(0,o.kt)("h2",{id:"executing-rotation-transformations"},"Executing Rotation Transformations"),(0,o.kt)("p",null,"While Euler angles are often a good way to specify 3D rotations, they can not directly be used to transfor points or vectors. To do that, they have to be converted to ."),(0,o.kt)("h2",{id:"rotations-using-rotation-matrices"},"Rotations using Rotation Matrices"),(0,o.kt)("p",null,"A rotation matrix"),(0,o.kt)("p",null,"T\nRR = I"),(0,o.kt)("h2",{id:"combining-rotations"},"Combining Rotations"),(0,o.kt)("p",null,"The fact that rotations. They can either be combined as w"),(0,o.kt)("p",null,"Math with Euler Angles"),(0,o.kt)("p",null,"Math with Quaternions"),(0,o.kt)("h2",{id:"interpolating-rotations"},"Interpolating Rotations"),(0,o.kt)("p",null,"To avoid issues with gimbal locks and flips, it is recommended to use quaternions when interpolating rotations."),(0,o.kt)("p",null,"Calculate the quaternion that represents the rotation you want to apply (e.g. moves the start rotation to the target rotation), and then just interpolate q with the identity quaternion using ",(0,o.kt)("inlineCode",{parentName:"p"},"slerp()"),". The resulting quaternion can then be used directly to transform ",(0,o.kt)("inlineCode",{parentName:"p"},"Vector"),"s or it can be transformed into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Matrix4")," transformation matrix."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  const qUnit = new Quaternion();\n  const qTarget = new Quaternion(...);\n\n  for (let ratio = 0; ratio < 1.0; ratio += 0.1) {\n    const qInterpolated = new Quaternion().slerp(qUnit, qTarget, ratio);\n  }\n")),(0,o.kt)("h2",{id:"background-rotations-are-complicated"},"Background: Rotations are Complicated"),(0,o.kt)("p",null,"If you are new to working with rotations and the amount of complications outlined in this article seem overwhelming, take some comfort in the fact that rotations in three and higher dimensional spaces are indeed quite complicated to treat mathematically."),(0,o.kt)("p",null,'As an example, several fundamental properties of rotations are highly dependent on the number of dimensions involved. To help the reader who has not worked extensively with rotations build some "intuition" for the fact that 3D rotations are non-trivial, the following summary shows how the nice, structured properties of 2D rotations gradually disappear as the number of dimensions increase:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"In two dimensions, rotations are highly structured and intuitive:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"A series of 2D rotations can be applied in any order (they commute)."),(0,o.kt)("li",{parentName:"ul"},'Any 2D rotation can be fully parametrized by a single value (the "angle").\nThe combination of two 2D rotations can always be expressed as another single rotation (simply by taking the sum of the angles of the two rotations).'))),(0,o.kt)("li",{parentName:"ul"},"In three dimensions rotation start to loose some structure:\n",(0,o.kt)("em",{parentName:"li"}," In 3D, rotations are no longer order-independent (they are not commutative), meaning that applying the same two rotations in different order will often yield different results.\n")," However, by ",(0,o.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem"},"Euler's Rotation Theorem"),", two 3D rotations around the origin can still always be expressed as (combined into) another single 3D rotation around the origin. ","*"," Also, a 3D rotation requires not two, but a minimum of three values to be fully specified."),(0,o.kt)("li",{parentName:"ul"},"To give some contrast, in four and higher dimensions:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Naturally, rotations still no longer commutative."),(0,o.kt)("li",{parentName:"ul"},'And worse: Euler\'s Rotation Theorem no longer holds. There are now two different types of basic rotations, and the combination of two rotations will in general not result in another "rotation", but another, more complex transformation.'),(0,o.kt)("li",{parentName:"ul"},'In addition, the number of parameters (degrees of freedom) required to fully specify a rotation grows with mind-boggling rapidity, as 2^(n-1) - 1, meaning that e.g. a "21 dimensional rotation" would require over one million values to be fully specified!')))),(0,o.kt)("h2",{id:"background-more-on-euler-angles"},"Background: More on Euler Angles"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Euler_angles"},"Euler angle values")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Axis Order")," - the order of rotations needs to be defined. There are 6 ways to order rotations around the three axis."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Choice of Axes"),' - "Classic Euler" angles follow a Z-Y-Z, convention, rotating around the same angle first and last. However, in modern applications (e.g. Aerospace and Nautical), the "Tait-Brya"'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Intrinsic or Extrinsic")," - One one also needs to define whether the angles are intrinsic or extrinsic.\nAs a comparison:"),(0,o.kt)("li",{parentName:"ul"},"three.js ",(0,o.kt)("inlineCode",{parentName:"li"},"Euler")," class uses intrinsic Tait-Bryan angles. \"Intrinsic\" means that rotations are performed with respect to the local coordinate system. That is, for order 'XYZ', the rotation is first around the local-X axis (which is the same as the world-X axis), then around local-Y (which may now be different from the world Y-axis), then local-Z (which may be different from the world Z-axis).")),(0,o.kt)("h2",{id:"remarks"},"Remarks"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'In this article, the word "axes" represents the plural of a (coordinate) "axis" (normally, the word "axes" refers to the X, Y and Z coordinate axes).'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Note")," that one of the most efficient way to specify rotations is to use the Euler-Rodrigues parameters, which has some of the quaternion representation without requiring the introduction of quaternion algebra. math.gl does not directly support this representation though although the vector/angle can easily be converted.")))}m.isMDXComponent=!0}}]);