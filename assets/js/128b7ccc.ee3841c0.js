"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8724],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>b});var i=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=i.createContext({}),s=function(e){var n=i.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=s(e.components);return i.createElement(u.Provider,{value:n},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,u=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(t),m=o,b=c["".concat(u,".").concat(m)]||c[m]||p[m]||r;return t?i.createElement(b,a(a({ref:n},d),{},{components:t})):i.createElement(b,a({ref:n},d))}));function b(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,a=new Array(r);a[0]=m;var l={};for(var u in n)hasOwnProperty.call(n,u)&&(l[u]=n[u]);l.originalType=e,l[c]="string"==typeof e?e:o,a[1]=l;for(var s=2;s<r;s++)a[s]=t[s];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7183:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=t(7462),o=(t(7294),t(3905));const r={},a="OrientedBoundingBox",l={unversionedId:"modules/culling/api-reference/oriented-bounding-box",id:"modules/culling/api-reference/oriented-bounding-box",title:"OrientedBoundingBox",description:"An OrientedBoundingBox is a closed and convex cuboid. It can provide a tighter bounding volume than a bounding sphere or an axis aligned bounding box in many cases.",source:"@site/../docs/modules/culling/api-reference/oriented-bounding-box.md",sourceDirName:"modules/culling/api-reference",slug:"/modules/culling/api-reference/oriented-bounding-box",permalink:"/docs/modules/culling/api-reference/oriented-bounding-box",draft:!1,editUrl:"https://github.com/uber-web/math.gl/tree/master/website/../docs/modules/culling/api-reference/oriented-bounding-box.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CullingVolume",permalink:"/docs/modules/culling/api-reference/culling-volume"},next:{title:"Plane",permalink:"/docs/modules/culling/api-reference/plane"}},u={},s=[{value:"Inheritance",id:"inheritance",level:2},{value:"Global Functions",id:"global-functions",level:2},{value:"makeOrientedBoundingBoxFromPoints(positions : Array3, result? : OrientedBoundingBox) : OrientedBoundingBox",id:"makeorientedboundingboxfrompointspositions--array3-result--orientedboundingbox--orientedboundingbox",level:3},{value:"Fields",id:"fields",level:2},{value:"center: Vector3",id:"center-vector3",level:3},{value:"halfAxes: Matrix3",id:"halfaxes-matrix3",level:3},{value:"readonly halfSize: number[]",id:"readonly-halfsize-number",level:3},{value:"readonly quaternion: Quaternion",id:"readonly-quaternion-quaternion",level:3},{value:"Methods",id:"methods",level:2},{value:"constructor(center = 0, 0, 0, halfAxes = 0, 0, 0, 0, 0, 0, 0, 0, 0) {",id:"constructorcenter--0-0-0-halfaxes--0-0-0-0-0-0-0-0-0-",level:3},{value:"constructor",id:"constructor",level:3},{value:"fromCenterHalfSizeQuaternion(center : number[], halfSize : number[], quaternion : number[]) : OrientedBoundingBox",id:"fromcenterhalfsizequaternioncenter--number-halfsize--number-quaternion--number--orientedboundingbox",level:3},{value:"clone() : OrientedBoundingBox",id:"clone--orientedboundingbox",level:3},{value:"equals(right: OrientedBoundingBox) : Boolean",id:"equalsright-orientedboundingbox--boolean",level:3},{value:"intersectPlane(plane : Plane) : INTERSECTION",id:"intersectplaneplane--plane--intersection",level:3},{value:"distanceTo(point : Number3) : Number",id:"distancetopoint--number3--number",level:3},{value:"distanceSquaredTo(point : Number3) : Number",id:"distancesquaredtopoint--number3--number",level:3},{value:"computePlaneDistances(position : Number3, direction : Number3, result : Number2]) : Number2",id:"computeplanedistancesposition--number3-direction--number3-result--number2--number2",level:3},{value:"Attribution",id:"attribution",level:2}],d={toc:s},c="wrapper";function p(e){let{components:n,...t}=e;return(0,o.kt)(c,(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"orientedboundingbox"},"OrientedBoundingBox"),(0,o.kt)("p",null,"An ",(0,o.kt)("inlineCode",{parentName:"p"},"OrientedBoundingBox")," is a closed and convex cuboid. It can provide a tighter bounding volume than a bounding sphere or an axis aligned bounding box in many cases."),(0,o.kt)("p",null,"The class support two representations of an oriented bounding box:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A half-axes based representation. 3 half axes vectors (",(0,o.kt)("inlineCode",{parentName:"li"},"halfAxes: Matrix3"),") describe size and orientation of a bounding box. This approach is used in the 3DTiles specification (",(0,o.kt)("a",{parentName:"li",href:"https://github.com/CesiumGS/3d-tiles/tree/master/specification#box"},"https://github.com/CesiumGS/3d-tiles/tree/master/specification#box"),")"),(0,o.kt)("li",{parentName:"ul"},"A half-size-quaternion based representation. A ",(0,o.kt)("inlineCode",{parentName:"li"},"halfSize: number[3]")," array describes size, a ",(0,o.kt)("inlineCode",{parentName:"li"},"quaternion: Quaternion")," describes orientation of a bounding box. This approach is used in the Indexed 3d Scene Layer (I3S) specification (",(0,o.kt)("a",{parentName:"li",href:"https://github.com/Esri/i3s-spec/blob/master/docs/1.7/obb.cmn.md"},"https://github.com/Esri/i3s-spec/blob/master/docs/1.7/obb.cmn.md"),").")),(0,o.kt)("h1",{id:"usage"},"Usage"),(0,o.kt)("p",null,"Create an ",(0,o.kt)("inlineCode",{parentName:"p"},"OrientedBoundingBox")," using a transformation matrix, a position where the box will be translated, and a scale."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import {Vector3} from '@math.gl/core';\nimport {OrientedBoundingBox} from '@math.gl/culling';\n\nconst center = new Vector3(1.0, 0.0, 0.0);\nconst halfAxes = new Matrix3().fromScale([1.0, 3.0, 2.0]);\nconst box = new OrientedBoundingBox(center, halfAxes);\n")),(0,o.kt)("p",null,"Sort bounding boxes from back to front"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"boxes.sort(\n  (boxA, boxB) =>\n    boxB.distanceSquaredTo(camera.positionWC) - boxA.distanceSquaredTo(camera.positionWC)\n);\n")),(0,o.kt)("p",null,"Compute an oriented bounding box enclosing two points."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import {makeOrientedBoundingBoxFromPoints} from '@math.gl/culling';\n\nconst box = makeOrientedBoundingBoxFromPoints([\n  [2, 0, 0],\n  [-2, 0, 0]\n]);\n")),(0,o.kt)("h2",{id:"inheritance"},"Inheritance"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"class OrientedBoundingBox implements")," ",(0,o.kt)("a",{parentName:"p",href:"./bounding-volume"},(0,o.kt)("inlineCode",{parentName:"a"},"BoundingVolume")),"."),(0,o.kt)("h2",{id:"global-functions"},"Global Functions"),(0,o.kt)("h3",{id:"makeorientedboundingboxfrompointspositions--array3-result--orientedboundingbox--orientedboundingbox"},"makeOrientedBoundingBoxFromPoints(positions : Array","[3][]",", result? : OrientedBoundingBox) : OrientedBoundingBox"),(0,o.kt)("p",null,"Computes an instance of an ",(0,o.kt)("inlineCode",{parentName:"p"},"OrientedBoundingBox")," of the given positions.\nThis is an implementation of Stefan Gottschalk's ",(0,o.kt)("a",{parentName:"p",href:"http://gamma.cs.unc.edu/users/gottschalk/main.pdf"},"Collision Queries using Oriented Bounding Boxes")," (PHD thesis)."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"positions")," List of ",(0,o.kt)("inlineCode",{parentName:"li"},"Vector3")," points that the bounding box will enclose."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"result")," Optional object onto which to store the result.")),(0,o.kt)("h2",{id:"fields"},"Fields"),(0,o.kt)("h3",{id:"center-vector3"},"center: Vector3"),(0,o.kt)("p",null,"The center position of the box."),(0,o.kt)("h3",{id:"halfaxes-matrix3"},"halfAxes: Matrix3"),(0,o.kt)("p",null,"The transformation matrix, to rotate the box to the right position."),(0,o.kt)("h3",{id:"readonly-halfsize-number"},"readonly halfSize: number[]"),(0,o.kt)("p",null,"The array with three half-sizes for the bounding box"),(0,o.kt)("h3",{id:"readonly-quaternion-quaternion"},"readonly quaternion: Quaternion"),(0,o.kt)("p",null,"The quaternion describing the orientation of the bounding box"),(0,o.kt)("h2",{id:"methods"},"Methods"),(0,o.kt)("h3",{id:"constructorcenter--0-0-0-halfaxes--0-0-0-0-0-0-0-0-0-"},"constructor(center = ","[0, 0, 0]",", halfAxes = ","[0, 0, 0, 0, 0, 0, 0, 0, 0]",") {"),(0,o.kt)("h3",{id:"constructor"},"constructor"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"center"),"=",(0,o.kt)("inlineCode",{parentName:"li"},"Vector3.ZERO")," The center of the box."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"halfAxes"),"=",(0,o.kt)("inlineCode",{parentName:"li"},"Matrix3.ZERO")," The three orthogonal half-axes of the bounding box. Equivalently, the transformation matrix, to rotate and scale a cube centered at the origin.")),(0,o.kt)("h3",{id:"fromcenterhalfsizequaternioncenter--number-halfsize--number-quaternion--number--orientedboundingbox"},"fromCenterHalfSizeQuaternion(center : number[], halfSize : number[], quaternion : number[]) : OrientedBoundingBox"),(0,o.kt)("p",null,"Create an OrientedBoundingBox from a half-size-quaternion based OBB"),(0,o.kt)("h3",{id:"clone--orientedboundingbox"},"clone() : OrientedBoundingBox"),(0,o.kt)("p",null,"Duplicates a OrientedBoundingBox instance."),(0,o.kt)("p",null,"Returns"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A new ",(0,o.kt)("inlineCode",{parentName:"li"},"OrientedBoundingBox")," instance.")),(0,o.kt)("h3",{id:"equalsright-orientedboundingbox--boolean"},"equals(right: OrientedBoundingBox) : Boolean"),(0,o.kt)("p",null,"Compares the provided OrientedBoundingBox componentwise and returns ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if they are equal, ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"right")," The second ",(0,o.kt)("inlineCode",{parentName:"li"},"OrientedBoundingBox"))),(0,o.kt)("p",null,"Returns"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"true")," if left and right are equal, ",(0,o.kt)("inlineCode",{parentName:"li"},"false")," otherwise.")),(0,o.kt)("h3",{id:"intersectplaneplane--plane--intersection"},"intersectPlane(plane : Plane) : INTERSECTION"),(0,o.kt)("p",null,"Determines which side of a plane the oriented bounding box is located."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"plane")," The plane to test against.")),(0,o.kt)("p",null,"Returns"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"INTERSECTION.INSIDE")," if the entire box is on the side of the plane the normal is pointing"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"INTERSECTION.OUTSIDE")," if the entire box is on the opposite side, and"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"INTERSECTION.INTERSECTING")," if the box intersects the plane.")),(0,o.kt)("h3",{id:"distancetopoint--number3--number"},"distanceTo(point : Number","[3]",") : Number"),(0,o.kt)("p",null,"Computes the estimated distance from the closest point on a bounding box to a point."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"point")," The point")),(0,o.kt)("p",null,"Returns"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The estimated distance from the bounding sphere to the point.")),(0,o.kt)("h3",{id:"distancesquaredtopoint--number3--number"},"distanceSquaredTo(point : Number","[3]",") : Number"),(0,o.kt)("p",null,"Computes the estimated distance squared from the closest point on a bounding box to a point."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"point")," The point")),(0,o.kt)("p",null,"Returns"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The estimated distance squared from the bounding sphere to the point.")),(0,o.kt)("h3",{id:"computeplanedistancesposition--number3-direction--number3-result--number2--number2"},"computePlaneDistances(position : Number","[3]",", direction : Number","[3]",", result : Number","[2]","]) : Number","[2]"),(0,o.kt)("p",null,"The distances calculated by the vector from the center of the bounding box to position projected onto direction."),(0,o.kt)("p",null,"If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the closest and farthest planes from position that intersect the bounding box."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"position")," The position to calculate the distance from."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"direction")," The direction from position."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"result")," An optional Interval to store the nearest and farthest distances.")),(0,o.kt)("p",null,"Returns"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The nearest and farthest distances on the bounding box from position in direction.")),(0,o.kt)("h2",{id:"attribution"},"Attribution"),(0,o.kt)("p",null,"This class was ported from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/AnalyticalGraphicsInc/cesium"},"Cesium")," under the Apache 2 License."))}p.isMDXComponent=!0}}]);