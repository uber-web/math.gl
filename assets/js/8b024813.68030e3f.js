"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5667],{4137:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var s=a.createContext({}),u=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=u(t.components);return a.createElement(s.Provider,{value:e},t.children)},d="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},c=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,r=t.originalType,s=t.parentName,p=l(t,["components","mdxType","originalType","parentName"]),d=u(n),c=o,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||r;return n?a.createElement(h,i(i({ref:e},p),{},{components:n})):a.createElement(h,i({ref:e},p))}));function h(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=n.length,i=new Array(r);i[0]=c;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l[d]="string"==typeof t?t:o,i[1]=l;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7532:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(7462),o=(n(7294),n(4137));const r={},i="3D Rotations",l={unversionedId:"developer-guide/math/rotations",id:"developer-guide/math/rotations",title:"3D Rotations",description:'The math.gl core module aims to provide the standard "3D math library" arsenal of mathematical tools. This includes tools for handling rotations in 2D and 3D via Euler angles, Quaternions and 4x4 matrix operations. As in any 3D math library, the key goals are enabling applications to easily and intuitively specify (parametrize) rotations, combine them with other rotations and other transformations, and ultimately transform points with the rotations or resulting transformations.',source:"@site/../docs/developer-guide/math/rotations.md",sourceDirName:"developer-guide/math",slug:"/developer-guide/math/rotations",permalink:"/math.gl/docs/developer-guide/math/rotations",draft:!1,editUrl:"https://github.com/uber-web/math.gl/tree/master/website/../docs/developer-guide/math/rotations.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"3D Coordinate Systems",permalink:"/math.gl/docs/developer-guide/math/coordinate-systems"},next:{title:"Floating Point",permalink:"/math.gl/docs/developer-guide/math/floating-point"}},s={},u=[{value:"Parametrizing 3D Rotations",id:"parametrizing-3d-rotations",level:2},{value:"Rotation Axis and Angle",id:"rotation-axis-and-angle",level:3},{value:"Euler Angles",id:"euler-angles",level:3},{value:"Unit Quaternions",id:"unit-quaternions",level:3},{value:"Rotation Matrices",id:"rotation-matrices",level:2},{value:"Properties of Rotation Matrices",id:"properties-of-rotation-matrices",level:2},{value:"Converting between Rotation Representations",id:"converting-between-rotation-representations",level:2},{value:"Executing Rotation Transformations",id:"executing-rotation-transformations",level:2},{value:"Rotations using Rotation Matrices",id:"rotations-using-rotation-matrices",level:2},{value:"Combining Rotations",id:"combining-rotations",level:2},{value:"Interpolating Rotations",id:"interpolating-rotations",level:2},{value:"Background: Rotations are Complicated",id:"background-rotations-are-complicated",level:2},{value:"Background: More on Euler Angles",id:"background-more-on-euler-angles",level:2},{value:"Remarks",id:"remarks",level:2}],p={toc:u},d="wrapper";function m(t){let{components:e,...n}=t;return(0,o.kt)(d,(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"3d-rotations"},"3D Rotations"),(0,o.kt)("p",null,'The math.gl core module aims to provide the standard "3D math library" arsenal of mathematical tools. This includes tools for handling rotations in 2D and 3D via ',(0,o.kt)("inlineCode",{parentName:"p"},"Euler")," angles, ",(0,o.kt)("inlineCode",{parentName:"p"},"Quaternion"),"s and 4x4 matrix operations. As in any 3D math library, the key goals are enabling applications to easily and intuitively specify (parametrize) rotations, combine them with other rotations and other transformations, and ultimately transform points with the rotations or resulting transformations."),(0,o.kt)("h2",{id:"parametrizing-3d-rotations"},"Parametrizing 3D Rotations"),(0,o.kt)("p",null,"A minimum of three values are required to fully specify a 3D rotation (another result of Euler's), e.g, Euler angles or unit quaternions."),(0,o.kt)("p",null,"However in many cases the best way to specify a rotation is to use four parameters: an axis and an angle."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Representation"),(0,o.kt)("th",{parentName:"tr",align:null},"Interpolation"),(0,o.kt)("th",{parentName:"tr",align:null},"Addition"),(0,o.kt)("th",{parentName:"tr",align:null},"Transforming points"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Vector/Angle"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"Good")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Quaternion"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent"),(0,o.kt)("td",{parentName:"tr",align:null},"Good")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4x4 Matrix"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent"),(0,o.kt)("td",{parentName:"tr",align:null},"Excellent")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Euler angle"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"-"),(0,o.kt)("td",{parentName:"tr",align:null},"-")))),(0,o.kt)("h3",{id:"rotation-axis-and-angle"},"Rotation Axis and Angle"),(0,o.kt)("p",null,"Per the Euler Rotation Theorem, any two 3D rotations can be combined into a single 3D rotation. A single 3D rotation happens around an axis, and the rotation is a certain angle. This means that it is possible to specify a rotation using four very understanable values: an axis and an angle."),(0,o.kt)("h3",{id:"euler-angles"},"Euler Angles"),(0,o.kt)("p",null,'One of the more "human readable" representation of a 3D rotation is the "Euler angle", simplistically, an "Euler angle" completely specifies a rotation using only 3 values, which are all "human readable" angles around the three coordinate axes, which is very appealing.'),(0,o.kt)("p",null,"However, the conventions for ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Euler_angles"},"Euler angle values")," can vary in a number of ways. Following three.js, the math.gl ",(0,o.kt)("inlineCode",{parentName:"p"},"Euler")," class uses intrinsic Tait-Bryan angles."),(0,o.kt)("p",null,'Note that the large number of representations means that Euler angles exchanged between e.g. different software systems may not be directly compatible (and in addition, converting between the various representations is not exactly easy), so unless care is taken this can cause "mind-numbing" confusion.'),(0,o.kt)("p",null,"Because of the variability, a good approach is often to be extremely careful when importing and exporting Euler angles from your code, and convert angle Euler angles to Matrix or Quaternion representations (which are much less ambiguous) for further manipulation."),(0,o.kt)("h3",{id:"unit-quaternions"},"Unit Quaternions"),(0,o.kt)("p",null,'"Unit quaternions" are normally the best representation for "manipulation" of 3D rotations. Manipulation here mainly refers to the "composition" or "addition" and interpolation of rotations.'),(0,o.kt)("p",null,"Note that unit quaternions are simply quaternions of norm (or length) equal to ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),", and while a general quaternion (as the name suggests) contains four components, a unit quaternion needs only three values to be fully specified."),(0,o.kt)("p",null,"Unit quaternions can be used to model 3 dimensional rotations."),(0,o.kt)("p",null,"qr",(0,o.kt)("em",{parentName:"p"},"v"),"qr-1"),(0,o.kt)("p",null,"Interpolation of quaternions is done using Spherical Linear intERPolation (aka SLERP)."),(0,o.kt)("h2",{id:"rotation-matrices"},"Rotation Matrices"),(0,o.kt)("p",null,"Rotations around arbitrary points can be treated as rotations around the origin simply by applying a translation before the rotation, and the inverse translation after the rotation. "),(0,o.kt)("p",null,"Thus, when combining rotations with other transformations (translations, scalings, projections etc), 4x4 matrices are the representation of choice."),(0,o.kt)("h2",{id:"properties-of-rotation-matrices"},"Properties of Rotation Matrices"),(0,o.kt)("p",null,"A rotation matrix"),(0,o.kt)("p",null,"T\nRR = I"),(0,o.kt)("p",null,"Note that a matrix R satisfying this can also include an inversion (improper rotation matrix)"),(0,o.kt)("h2",{id:"converting-between-rotation-representations"},"Converting between Rotation Representations"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"new Euler();\nnew Euler();\n")),(0,o.kt)("h2",{id:"executing-rotation-transformations"},"Executing Rotation Transformations"),(0,o.kt)("p",null,"While Euler angles are often a good way to specify 3D rotations, they can not directly be used to transfor points or vectors. To do that, they have to be converted to ."),(0,o.kt)("h2",{id:"rotations-using-rotation-matrices"},"Rotations using Rotation Matrices"),(0,o.kt)("p",null,"A rotation matrix"),(0,o.kt)("p",null,"T\nRR = I"),(0,o.kt)("h2",{id:"combining-rotations"},"Combining Rotations"),(0,o.kt)("p",null,"The fact that rotations. They can either be combined as w"),(0,o.kt)("p",null,"Math with Euler Angles"),(0,o.kt)("p",null,"Math with Quaternions"),(0,o.kt)("h2",{id:"interpolating-rotations"},"Interpolating Rotations"),(0,o.kt)("p",null,"To avoid issues with gimbal locks and flips, it is recommended to use quaternions when interpolating rotations."),(0,o.kt)("p",null,"Calculate the quaternion that represents the rotation you want to apply (e.g. moves the start rotation to the target rotation), and then just interpolate q with the identity quaternion using ",(0,o.kt)("inlineCode",{parentName:"p"},"slerp()"),". The resulting quaternion can then be used directly to transform ",(0,o.kt)("inlineCode",{parentName:"p"},"Vector"),"s or it can be transformed into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Matrix4")," transformation matrix."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"  const qUnit = new Quaternion();\n  const qTarget = new Quaternion(...);\n\n  for (let ratio = 0; ratio < 1.0; ratio += 0.1) {\n    const qInterpolated = new Quaternion().slerp(qUnit, qTarget, ratio);\n  }\n")),(0,o.kt)("h2",{id:"background-rotations-are-complicated"},"Background: Rotations are Complicated"),(0,o.kt)("p",null,"If you are new to working with 3D rotations it can be good to have an awareness of how they differ mathematically from 2D rotations"),(0,o.kt)("p",null,"In two dimensions, rotations represent a highly structured and intuitive set of operations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A series of 2D rotations can be applied in any order (they commute)."),(0,o.kt)("li",{parentName:"ul"},"The combination of two 2D rotations can always be expressed as another single rotation (simply by taking the sum of the angles of the two rotations)."),(0,o.kt)("li",{parentName:"ul"},'Any 2D rotation can be fully parametrized by a single value (the "angle").')),(0,o.kt)("p",null,'However, in three dimensions, rotations start to loose some "structure":'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"In 3D, rotations are no longer order-independent (they are not commutative), meaning that applying the same two rotations in different order will often yield different results."),(0,o.kt)("li",{parentName:"ul"},"However, by ",(0,o.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem"},"Euler's Rotation Theorem"),", two 3D rotations around the origin can still always be expressed as (combined into) another single 3D rotation around the origin. "),(0,o.kt)("li",{parentName:"ul"},"Also, a 3D rotation requires not two, but three values to be fully specified.")),(0,o.kt)("p",null,'While math.gl does not support rotations in four and higher dimensions, it should be no surprised that rotations continue to "loose structure" as the number of dimensions increase:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Higher dimension rotations are also not commutative."),(0,o.kt)("li",{parentName:"ul"},'Euler\'s Rotation Theorem no longer holds. There are now two different "types" of basic rotations, and the combination of two rotations will in general not even result in another "rotation", but another, more complex transformation.'),(0,o.kt)("li",{parentName:"ul"},"In addition, the number of parameters (degrees of freedom) required to fully specify a rotation grows with mind-boggling rapidity, as ",(0,o.kt)("inlineCode",{parentName:"li"},"2^(n-1) - 1"),', (meaning that e.g. a "21 dimensional rotation" would require over one million values to be fully specified).')),(0,o.kt)("h2",{id:"background-more-on-euler-angles"},"Background: More on Euler Angles"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Euler_angles"},"Euler angle values")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Axis Order")," - the order of rotations needs to be defined. There are 6 ways to order rotations around the three axis."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Choice of Axes"),' - "Classic Euler" angles follow a Z-Y-Z, convention, rotating around the same angle first and last. However, in modern applications (e.g. Aerospace and Nautical), the "Tait-Brya"'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Intrinsic or Extrinsic")," - One one also needs to define whether the angles are intrinsic or extrinsic.\nAs a comparison:"),(0,o.kt)("li",{parentName:"ul"},"three.js ",(0,o.kt)("inlineCode",{parentName:"li"},"Euler")," class uses intrinsic Tait-Bryan angles. \"Intrinsic\" means that rotations are performed with respect to the local coordinate system. That is, for order 'XYZ', the rotation is first around the local-X axis (which is the same as the world-X axis), then around local-Y (which may now be different from the world Y-axis), then local-Z (which may be different from the world Z-axis).")),(0,o.kt)("h2",{id:"remarks"},"Remarks"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'In this article, the word "axes" represents the plural of a (coordinate) "axis" (normally, the word "axes" refers to the X, Y and Z coordinate axes).'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Note")," that one of the most efficient way to specify rotations is to use the Euler-Rodrigues parameters, which has some of the quaternion representation without requiring the introduction of quaternion algebra. math.gl does not directly support this representation although the vector/angle can easily be converted.")))}m.isMDXComponent=!0}}]);