"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6918],{3905:(e,t,i)=>{i.d(t,{Zo:()=>d,kt:()=>N});var n=i(7294);function l(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){l(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function o(e,t){if(null==e)return{};var i,n,l=function(e,t){if(null==e)return{};var i,n,l={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(l[i]=e[i]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(l[i]=e[i])}return l}var p=n.createContext({}),u=function(e){var t=n.useContext(p),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},d=function(e){var t=u(e.components);return n.createElement(p.Provider,{value:t},e.children)},m="mdxType",s={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var i=e.components,l=e.mdxType,a=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=u(i),k=l,N=m["".concat(p,".").concat(k)]||m[k]||s[k]||a;return i?n.createElement(N,r(r({ref:t},d),{},{components:i})):n.createElement(N,r({ref:t},d))}));function N(e,t){var i=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=i.length,r=new Array(a);r[0]=k;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[m]="string"==typeof e?e:l,r[1]=o;for(var u=2;u<a;u++)r[u]=i[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}k.displayName="MDXCreateElement"},7769:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>s,frontMatter:()=>a,metadata:()=>o,toc:()=>u});var n=i(7462),l=(i(7294),i(3905));const a={},r="Web Mercator Utility Functions",o={unversionedId:"modules/web-mercator/api-reference/web-mercator-utils",id:"modules/web-mercator/api-reference/web-mercator-utils",title:"Web Mercator Utility Functions",description:"lngLatToWorld(lngLat)",source:"@site/../docs/modules/web-mercator/api-reference/web-mercator-utils.md",sourceDirName:"modules/web-mercator/api-reference",slug:"/modules/web-mercator/api-reference/web-mercator-utils",permalink:"/math.gl/docs/modules/web-mercator/api-reference/web-mercator-utils",draft:!1,editUrl:"https://github.com/uber-web/math.gl/tree/master/website/../docs/modules/web-mercator/api-reference/web-mercator-utils.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/math.gl/docs/modules/web-mercator/"},next:{title:"WebMercatorViewport",permalink:"/math.gl/docs/modules/web-mercator/api-reference/web-mercator-viewport"}},p={},u=[{value:"<code>lngLatToWorld(lngLat)</code>",id:"lnglattoworldlnglat",level:3},{value:"<code>worldToLngLat(xy, scale)</code>",id:"worldtolnglatxy-scale",level:3},{value:"<code>worldToPixels(xyz, projectionMatrix)</code>",id:"worldtopixelsxyz-projectionmatrix",level:3},{value:"<code>pixelsToWorld(xyz, unprojectionMatrix, targetZ)</code>",id:"pixelstoworldxyz-unprojectionmatrix-targetz",level:3},{value:"<code>getMeterZoom(viewport)</code>",id:"getmeterzoomviewport",level:3},{value:"<code>getDistanceScales(viewport)</code>",id:"getdistancescalesviewport",level:3},{value:"<code>addMetersToLngLat(lngLatZ, xyz)</code>",id:"addmeterstolnglatlnglatz-xyz",level:3},{value:"<code>getViewMatrix(viewport)</code>",id:"getviewmatrixviewport",level:3},{value:"<code>getProjectionMatrix(viewport)</code>",id:"getprojectionmatrixviewport",level:3},{value:"<code>getProjectionParameters({width, height, altitude, fovy, pitch, farZMultiplier}})</code>",id:"getprojectionparameterswidth-height-altitude-fovy-pitch-farzmultiplier",level:3},{value:"<code>altitudeToFovy(altitude)</code>",id:"altitudetofovyaltitude",level:3},{value:"<code>fovyToAltitude(fovy)</code>",id:"fovytoaltitudefovy",level:3},{value:"<code>fitBounds(opts)</code>",id:"fitboundsopts",level:3},{value:"<code>normalizeViewportProps(viewport)</code>",id:"normalizeviewportpropsviewport",level:3},{value:"<code>flyToViewport(startProps, endProps, t, opts)</code>",id:"flytoviewportstartprops-endprops-t-opts",level:3},{value:"<code>getFlyToDuration(startProps, endProps, opts)</code>",id:"getflytodurationstartprops-endprops-opts",level:3}],d={toc:u},m="wrapper";function s(e){let{components:t,...i}=e;return(0,l.kt)(m,(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"web-mercator-utility-functions"},"Web Mercator Utility Functions"),(0,l.kt)("p",{class:"badges"},(0,l.kt)("img",{src:"https://img.shields.io/badge/From-v3.1-blue.svg?style=flat-square",alt:"From-v3.1"})),(0,l.kt)("h3",{id:"lnglattoworldlnglat"},(0,l.kt)("inlineCode",{parentName:"h3"},"lngLatToWorld(lngLat)")),(0,l.kt)("p",null,"Project a coordinate on sphere onto the 512x512 Web Mercator plane."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"lngLat")," (Array, required) - Specifies a point on the sphere to project. ",(0,l.kt)("inlineCode",{parentName:"li"},"[lng,lat]")," in degrees.")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[x, y]"))),(0,l.kt)("h3",{id:"worldtolnglatxy-scale"},(0,l.kt)("inlineCode",{parentName:"h3"},"worldToLngLat(xy, scale)")),(0,l.kt)("p",null,"Unproject a coordinate from the 512x512 Web Mercator plane back to the sphere."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"xy")," (Array, required) - Specifies a point on the Web Mercator tile to unproject. ",(0,l.kt)("inlineCode",{parentName:"li"},"[x, y]")," in pixels.")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[lng, lat]"))),(0,l.kt)("h3",{id:"worldtopixelsxyz-projectionmatrix"},(0,l.kt)("inlineCode",{parentName:"h3"},"worldToPixels(xyz, projectionMatrix)")),(0,l.kt)("p",null,"Project a coordinate from the Web Mercator coordinate system to screen."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"xyz")," (Array, required) - Specifies a point in the Web Mercator tile. ",(0,l.kt)("inlineCode",{parentName:"li"},"z")," is the elevation and optional."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"projectionMatrix")," (Matrix4, required) - The projection matrix.")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[x, y, z]")," - coordinates on screen, ",(0,l.kt)("inlineCode",{parentName:"li"},"z")," is the pixel depth.")),(0,l.kt)("h3",{id:"pixelstoworldxyz-unprojectionmatrix-targetz"},(0,l.kt)("inlineCode",{parentName:"h3"},"pixelsToWorld(xyz, unprojectionMatrix, targetZ)")),(0,l.kt)("p",null,"Project a coordinate from screen to the Web Mercator coordinate system."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"xyz")," (Array, required) - Specifies a point on screen. ",(0,l.kt)("inlineCode",{parentName:"li"},"z")," is the pixel depth and optional."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"unprojectionMatrix")," (Matrix4, required) - The unprojection matrix."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"targetZ")," (Number, optional) - If pixel depth is not specified, ",(0,l.kt)("inlineCode",{parentName:"li"},"targetZ")," is used as the elevation plane to unproject onto. Default ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),".")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[x, y, z]")," - coordinates on the Web Mercator tile, ",(0,l.kt)("inlineCode",{parentName:"li"},"z")," is the elevation.")),(0,l.kt)("h3",{id:"getmeterzoomviewport"},(0,l.kt)("inlineCode",{parentName:"h3"},"getMeterZoom(viewport)")),(0,l.kt)("p",null,"Returns the zoom level that gives a 1 meter pixel at a certain latitude."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport")," (Object) - viewport props"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.latitude")," (Number, required)")),(0,l.kt)("h3",{id:"getdistancescalesviewport"},(0,l.kt)("inlineCode",{parentName:"h3"},"getDistanceScales(viewport)")),(0,l.kt)("p",null,"Calculate linear scales for quick conversion between meters/degrees/pixels distances around the given lat/lon."),(0,l.kt)("p",null,"In mercator projection mode, the distance scales vary significantly with latitude. The scale is only reasonably accurate locally."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport")," (Object) - viewport props"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.longitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.latitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.highPrecision")," (bool, optional) - default ",(0,l.kt)("inlineCode",{parentName:"li"},"false"))),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"distanceScales")," (Object)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"distanceScales.unitsPerMeter")," (Array) - world units per meter in ",(0,l.kt)("inlineCode",{parentName:"li"},"[x, y, z]"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"distanceScales.metersPerUnit")," (Array) - meters per world unit in ",(0,l.kt)("inlineCode",{parentName:"li"},"[x, y, z]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"distanceScales.unitsPerDegree")," (Array) - world units per degree in ",(0,l.kt)("inlineCode",{parentName:"li"},"[x, y, z]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"distanceScales.degreesPerUnit")," (Array) - degree per world unit in ",(0,l.kt)("inlineCode",{parentName:"li"},"[x, y, z]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"distanceScales.unitsPerMeter2")," (Array) - if ",(0,l.kt)("inlineCode",{parentName:"li"},"highPrecision")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"true"),", returns world units per meter adjustment in ",(0,l.kt)("inlineCode",{parentName:"li"},"[x2, y2, z2]"),". It offers a cheap way to compensate for the precision loss with latitude. Amends ",(0,l.kt)("inlineCode",{parentName:"li"},"unitsPerMeter")," by y offset (in meters): ",(0,l.kt)("inlineCode",{parentName:"li"},"[x + x2 * dy, y + y2 * dy, z + z2 * dy]"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"distanceScales.unitsPerDegree2")," (Array) - if ",(0,l.kt)("inlineCode",{parentName:"li"},"highPrecision")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"true"),", returns world units per degree adjustment in ",(0,l.kt)("inlineCode",{parentName:"li"},"[x2, y2, z2]"),". It offers a cheap way to compensate for the precision loss with latitude. Amends ",(0,l.kt)("inlineCode",{parentName:"li"},"unitsPerDegree")," by y offset (in degrees): ",(0,l.kt)("inlineCode",{parentName:"li"},"[x + x2 * dy, y + y2 * dy, z + z2 * dy]"),".")),(0,l.kt)("h3",{id:"addmeterstolnglatlnglatz-xyz"},(0,l.kt)("inlineCode",{parentName:"h3"},"addMetersToLngLat(lngLatZ, xyz)")),(0,l.kt)("p",null,"Offset a spherical position by meters."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"lngLatZ")," (Array) - origin in ",(0,l.kt)("inlineCode",{parentName:"li"},"[lng, lat, alt]"),". Altitude is optional."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"xyz")," (Array) - offset from the origin ",(0,l.kt)("inlineCode",{parentName:"li"},"[x, y, z]")," in meters. ",(0,l.kt)("inlineCode",{parentName:"li"},"x")," is easting and ",(0,l.kt)("inlineCode",{parentName:"li"},"y")," is northing. ",(0,l.kt)("inlineCode",{parentName:"li"},"z")," is optional.")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[lng, lat]")," if the third component in neither argument is specified, or"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[lng, lat, alt]")," otherwise.")),(0,l.kt)("h3",{id:"getviewmatrixviewport"},(0,l.kt)("inlineCode",{parentName:"h3"},"getViewMatrix(viewport)")),(0,l.kt)("p",null,"Get a transform matrix that projects from the mercator (pixel) space into the camera (view) space. Centers the map at the given coordinates."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport")," (Object) - viewport props"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.height")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.pitch")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.bearing")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.scale")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.altitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.center")," (Array, optional) - pre-calculated world position of map center using ",(0,l.kt)("inlineCode",{parentName:"li"},"getWorldPosition"),". Default ",(0,l.kt)("inlineCode",{parentName:"li"},"[0, 0]"),".")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewMatrix")," (Array) 4x4 matrix.")),(0,l.kt)("h3",{id:"getprojectionmatrixviewport"},(0,l.kt)("inlineCode",{parentName:"h3"},"getProjectionMatrix(viewport)")),(0,l.kt)("p",null,"Get a transform matrix that projects from camera (view) space to clipspace."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport")," (Object) - viewport props"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.width")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.height")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.pitch")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.scale")," (Number, optional) - required if ",(0,l.kt)("inlineCode",{parentName:"li"},"center")," is specified"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.center")," (Number[], optional) - offset of the target, vec3 in world space"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.offset")," (Number[], optional) - offset of the focal point, vec2 in screen space"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.fovy")," (Number, optional) - field of view in degrees"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.altitude")," (Number, optional) - if provided, field of view is calculated using ",(0,l.kt)("inlineCode",{parentName:"li"},"altitudeToFovy()")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.nearZMultiplier")," (Number, optional) - near plane multiplier. Default ",(0,l.kt)("inlineCode",{parentName:"li"},"1"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.farZMultiplier")," (Number, optional) - far plane multiplier. Default ",(0,l.kt)("inlineCode",{parentName:"li"},"1"))),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("p",null,"To match Mapbox's z-buffer, use these parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Before 0.29:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"nearZMultiplier"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"0.1")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"farZMultiplier"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"1")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Starting 0.29:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"nearZMultiplier"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"1 / viewport.height")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"farZMultiplier"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"1.01")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fovy"),": ",(0,l.kt)("inlineCode",{parentName:"p"},"altitudeToFovy(1.5)")))),(0,l.kt)("h3",{id:"getprojectionparameterswidth-height-altitude-fovy-pitch-farzmultiplier"},(0,l.kt)("inlineCode",{parentName:"h3"},"getProjectionParameters({width, height, altitude, fovy, pitch, farZMultiplier}})")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"width")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.pitch")," (Number, optional) - default ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.scale")," (Number, optional) - required if ",(0,l.kt)("inlineCode",{parentName:"li"},"center")," is specified"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.center")," (Number[], optional) - offset of the target, vec3 in world space"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.offset")," (Number[], optional) - offset of the focal point, vec2 in screen space"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.fovy")," (Number, optional) - field of view in degrees"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"altitude")," (Number, optional) - if provided, field of view is calculated using ",(0,l.kt)("inlineCode",{parentName:"li"},"altitudeToFovy()")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"farZMultiplier")," (Number, optional) - near plane multiplier. Default ",(0,l.kt)("inlineCode",{parentName:"li"},"1"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"farZMultiplier")," (Number, optional) - far plane multiplier. Default ",(0,l.kt)("inlineCode",{parentName:"li"},"1"),".")),(0,l.kt)("p",null,"Returns"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Object with ",(0,l.kt)("inlineCode",{parentName:"li"},"{fov, aspect, focalDistance, near, far}")," fields. Note that returned ",(0,l.kt)("inlineCode",{parentName:"li"},"fov")," is in radians")),(0,l.kt)("h3",{id:"altitudetofovyaltitude"},(0,l.kt)("inlineCode",{parentName:"h3"},"altitudeToFovy(altitude)")),(0,l.kt)("p",null,"Convert an altitude to field of view such that the focal distance is equal to the altitude."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"altitude")," (Number, required) - altitude of camera in screen units")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fovy")," field of view in degrees")),(0,l.kt)("h3",{id:"fovytoaltitudefovy"},(0,l.kt)("inlineCode",{parentName:"h3"},"fovyToAltitude(fovy)")),(0,l.kt)("p",null,"Convert a field of view to an altitude equal to the focal distance"),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fovy")," (Number, required) field of view in degrees")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"altitude")," altitude of camera in screen units")),(0,l.kt)("h3",{id:"fitboundsopts"},(0,l.kt)("inlineCode",{parentName:"h3"},"fitBounds(opts)")),(0,l.kt)("p",null,"Returns map settings (longitude, latitude and zoom) that will contain the provided corners within the provided dimensions. Only supports non-perspective mode."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts")," (Object) - options"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.width")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.height")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.bounds")," (Array, required) - opposite corners specified as ",(0,l.kt)("inlineCode",{parentName:"li"},"[[lon, lat], [lon, lat]]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.minExtent")," (Number, optional) - If supplied, the bounds used to calculate the new map settings will be expanded if the delta width or height of the supplied ",(0,l.kt)("inlineCode",{parentName:"li"},"bounds")," is smaller than this value."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.maxZoom"),"=",(0,l.kt)("inlineCode",{parentName:"li"},"24")," (Number, optional) - The returned zoom value will be capped to this value. Avoids returning infinite ",(0,l.kt)("inlineCode",{parentName:"li"},"zoom")," when the supplied ",(0,l.kt)("inlineCode",{parentName:"li"},"bounds")," have zero width or height deltas."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.padding"),"=",(0,l.kt)("inlineCode",{parentName:"li"},"0")," (Number, optional) - the amount of padding in pixels to add to the given bounds."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.offset"),"=",(0,l.kt)("inlineCode",{parentName:"li"},"[0,0]")," (Array, optional) - the center of the given bounds relative to the map's center, ",(0,l.kt)("inlineCode",{parentName:"li"},"[x, y]")," measured in pixels.")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{longitude, latitude, zoom}"))),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"minExtent")," - Note that this value represents delta latitude/longitudes and value of ",(0,l.kt)("inlineCode",{parentName:"li"},"0.01")," would roughly represent 1km.")),(0,l.kt)("h3",{id:"normalizeviewportpropsviewport"},(0,l.kt)("inlineCode",{parentName:"h3"},"normalizeViewportProps(viewport)")),(0,l.kt)("p",null,"This will adjust the map center and zoom so that the projected map fits into the target viewport size without white gaps."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport")," (Object)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.width")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.height")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.longitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.latitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.zoom")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport.pitch")," (Number, optional)")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"viewport")," - normalized ",(0,l.kt)("inlineCode",{parentName:"li"},"{width, height, longitude, latitude, zoom, pitch, bearing}"))),(0,l.kt)("h3",{id:"flytoviewportstartprops-endprops-t-opts"},(0,l.kt)("inlineCode",{parentName:"h3"},"flyToViewport(startProps, endProps, t, opts)")),(0,l.kt)("p",null,"While flying from one viewport to another, returns in-transition viewport props at a given time. This util function implements the algorithm described in \u201cSmooth and efficient zooming and panning.\u201d by Jarke J. van Wijk and Wim A.A. Nuij."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps")," (Object) - viewport to fly from"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.width")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.height")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.longitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.latitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.zoom")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps")," (Object) - viewport to fly from"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps.longitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps.latitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps.zoom")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"t")," (Number) - a time factor between 0 and 1. ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," indicates the start of the transition, ",(0,l.kt)("inlineCode",{parentName:"li"},"1")," indicates the end of the transition."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts")," (Object, optional)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.curve"),' (Number, optional, default: 1.414) - The zooming "curve" that will occur along the flight path, .')),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{longitude, latitude, zoom}"))),(0,l.kt)("h3",{id:"getflytodurationstartprops-endprops-opts"},(0,l.kt)("inlineCode",{parentName:"h3"},"getFlyToDuration(startProps, endProps, opts)")),(0,l.kt)("p",null,"Returns time in milliseconds, that is required perform transition from one viewport to another. Time returned is proportional to the distance we are transitioning to. This util function implements mapbox-gl-js (",(0,l.kt)("a",{parentName:"p",href:"https://docs.mapbox.com/mapbox-gl-js/api/#map#flyto"},"https://docs.mapbox.com/mapbox-gl-js/api/#map#flyto"),") duration calculation."),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps")," (Object) - viewport to fly from"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.width")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.height")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.longitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.latitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"startProps.zoom")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps")," (Object) - viewport to fly from"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps.longitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps.latitude")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"endProps.zoom")," (Number, required)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts")," (Object, optional) - optional parameters that effect duration calculation."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.curve"),' (Number, optional, default: 1.414) - The zooming "curve" that will occur along the flight path.'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.speed")," (Number, optional, default: 1.2) - The average speed of the animation defined in relation to ",(0,l.kt)("inlineCode",{parentName:"li"},"options.curve"),", it linearly affects the duration, higher speed returns smaller durations and vice versa."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.screenSpeed")," (Number, optional) - The average speed of the animation measured in screenfuls per second. Similar to ",(0,l.kt)("inlineCode",{parentName:"li"},"opts.speed")," it linearly affects the duration, when specified ",(0,l.kt)("inlineCode",{parentName:"li"},"opts.speed")," is ignored."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"opts.maxDuration")," (Number, optional) - Maximum duration in milliseconds, if calculated duration exceeds this value, ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," is returned.")),(0,l.kt)("p",null,"Returns:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"duration")," Number, in milliseconds.")))}s.isMDXComponent=!0}}]);